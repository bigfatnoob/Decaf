/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  MULTI = true;
  NODE_DEFAULT_VOID = true;
  NODE_PREFIX = "";
  STATIC = false;
}

PARSER_BEGIN(Decaf)
package stage2;
import java.util.*;
public class Decaf
{
  public static SymbolTable SYMBOL_TABLE = new SymbolTable();
  /**
  * Mode = 0 represents scope construction
    Mode = 1 represents symbol table construction 
  */
  public static int MODE = 0;
  
  public static void main(String args []) throws Exception
  {
    Decaf parser;
    if (args.length == 1) {
      try {
        parser = new Decaf(new java.io.FileInputStream(args[0]));  
      } catch (java.io.FileNotFoundException e) {
        System.out.println("File "+args[0]+ " not found," +
            " reading from terminal instead");
        parser = new Decaf(System.in);
      }
    } else {
      System.out.println("Reading from standard input...");
      parser =  new Decaf(System.in);
    }
    start_AST start = null;
    try
    {
      start = parser.Start();
      System.out.println("Parsed Successfully.");
      MODE = 1;
      parser = new Decaf(new java.io.FileInputStream(args[0]));
      start = parser.Start();
      ScopeFactory sf = ScopeFactory.getScopeFactory();
      /*for(String key: SYMBOL_TABLE.getTable().keySet()) {
        System.out.println(SYMBOL_TABLE.getTable().get(key));      }*/
      //start.dump(" -> ");
    }
    catch (Exception e)
    {
      System.out.println("ERROR : " + e.getMessage());
      throw e;
    }
    
  }
}

PARSER_END(Decaf)

SKIP :  /* Whitespace */
{
  " "
| "\r"
| "\t"
| "\n"
| <"//"(~["\n","\r"])*("\n"|"\r"|"\n\r")>   // Single Line Comment
| <"/*">: CMNT_BODY                         // Multi Line Comment
}

<CMNT_BODY>
SKIP:
{
  <"*/">: DEFAULT
| <~[]>
}



TOKEN : 
{
  /* Keywords */
  < BREAK : "break">
| < CLASS : "class">
| < CONTINUE : "continue">
| < ELSE : "else">
| < EXTENDS : "extends">
| < IF : "if">
| < NEW : "new">
| < PRIVATE : "private">
| < PROTECTED : "protected">
| < PUBLIC : "public">
| < RETURN : "return">
| < STATIC : "static">
| < SUPER : "super">
| < THIS : "this">
| < WHILE : "while">
| < BOOLEAN : "boolean">
| < CHAR : "char" >
| < VOID : "void" >
| < INT : "int">
  /* Forbidden Keywords from JAVA */
| < ABSTRACT : "abstract">
| < BYTE : "byte">
| < CASE : "case">
| < CATCH : "catch">
| < CONST : "const">
| < DEFLT : "default">
| < DO : "do">
| < DOUBLE : "double">
| < FINAL : "final">
| < FINALLY : "finally">
| < FOR : "for">
| < IMPLEMENTS : "implements">
| < IMPORT : "import">
| < INSTANCEOF : "instanceof">
| < INTERFACE : "interface">
| < LONG : "long">
| < NATIVE : "native">
| < GOTO : "goto">
| < PACKAGE : "package">
| < SHORT : "short">
| < SWITCH : "switch">
| < SYNCHRONIZED : "synchronized">
| < THROW : "throw">
| < THROWS : "throws">
| < TRANSIENT : "transient">
| < TRY : "try">
| < VOLATILE : "volatile">
  /* Reserved for possible future extension */
| < BYVALUE : "byvalue">
| < CAST : "cast">
| < FUTURE : "future">
| < GENERIC : "generic">
| < INNER : "inner">
| < NONE : "none">
| < OPERATOR : "operator">
| < OUTER : "outer">
| < REST : "rest">
| < VAR : "var">
  /* Literals */
| < INTEGER: "0"|(["1"-"9"](["0"-"9"])*)>
| < TRUE: "true" >
| < FALSE: "false" >
// TODO verify character definition
//| < CHARLITERAL: "'"(~["'", "\\"])|("\\"["a"-"z", "A"-"Z", "0"-"9"])|(" ")"'">
| < CHARLITERAL: "'"((~["'", "\\"])|" "|("\\t")|("\\n"))"'">
| < STRINGLITERAL: "\""((~["\"","\n","\r"])|("\\\""))*"\"">
| < NULL: "null">
  /* Punctuation */
| < LP: "(" >
| < RP: ")" >
| < LCB: "{" >
| < RCB: "}" >
| < LSB: "[" >
| < RSB: "]" >
| < SCOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
  /* Operators */
| < ASSIGN: "=" >
| < GREATER: ">" >
| < LESSER: "<" >
| < NOT: "!" >
| < EQUAL: "==" >
| < GREATEREQ: ">=" >
| < LESSEREQ: "<=" >
| < NOTEQUAL: "!=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < AND: "&&">
| < OR: "||">
| < MODULO: "%">
  /* Identifiers */
| < #Let : ["a"-"z", "A"-"Z"]>
| < #Dig : ["0"-"9"]>
| < ID: ("$"|"_"|<Let>)("$"|"_"|<Let>|<Dig>)*>
| < EMPTY : ""> : MATCH_NON_EMPTY
}

< MATCH_NON_EMPTY>
TOKEN:
{
  <NON_EMPTY : ~[]>
}

String ID():
{
  Token t;
}
{
  t = <ID>{return t.image;}
}

start_AST Start() #start_AST:
{
  Unit classUnit = null;
  List<Unit> classUnitList = new ArrayList<Unit >();
}
{
  {SYMBOL_TABLE.enterScope(true, MODE);
  if (MODE==1) {	  SYMBOL_TABLE.add("String", UnitType.CLASS);
	  SYMBOL_TABLE.add("IO", UnitType.CLASS);
	  SYMBOL_TABLE.add("Object", UnitType.CLASS);}
  }
  (classUnit = Class(){classUnitList.add(classUnit);})*
  {SYMBOL_TABLE.exitScope(MODE);}
  <EOF>
  {
    //jjtThis.setClasses(classUnitList);
    return jjtThis;
  }
}

Unit Class():
{
  ClassUnit classUnit = null;
  ClassUnit superClassUnit = null;
  List<Unit> classFields = new ArrayList<Unit>();
  List<Unit> classFieldsCollection = new ArrayList<Unit>();
  String className = null;
  String superClassName = null;
}
{
  <CLASS> className = ID() (< EXTENDS > superClassName = ID())? 
    {
        if  (MODE == 0){
          classUnit = (ClassUnit)UnitFactory.generateUnit(UnitType.CLASS);
          classUnit.setName(className);
        } else {
		    classUnit = (ClassUnit) SYMBOL_TABLE.add(className, UnitType.CLASS);
		    if (superClassName != null) {
		      IntegerMuted intMuted = new IntegerMuted(-1);
		      superClassUnit = (ClassUnit)SYMBOL_TABLE.lookUp(superClassName, UnitType.CLASS, intMuted);
		      if (superClassUnit == null){
		        throw new ParseException("Super class " + superClassName + " has not been declared.");		      }
		      classUnit.setSuperClass(superClassUnit);		    }
        }
    }
    <LCB>
    {SYMBOL_TABLE.enterScopeForUnit(classUnit,MODE);}
    (classFields = Member(){classFieldsCollection.addAll(classFields);})*
    {
      if (MODE == 1) {        classUnit.setMembersAndMethods(classFields);
      }    }
    <RCB>
    {
      SYMBOL_TABLE.exitScope(MODE);
      return classUnit;    }
}

List<Unit> Member():
{
  Unit member = null;
  List<Unit> memberList = null;
  List<Unit> allMembers = new ArrayList<Unit>();
}
{
  LOOKAHEAD(10)
  memberList = Field(){allMembers.addAll(memberList); return allMembers;}
  |LOOKAHEAD(10)
  member = Method(){allMembers.add(member); return allMembers;}
  |LOOKAHEAD(10)
  member = Ctor(){
    MethodUnit cMember = (MethodUnit)member;
    cMember.setConstructor(true);
    allMembers.add(cMember); return allMembers;
  }
}

List<Unit> Field():
{
  FieldDetails fieldDetails = new FieldDetails();
  Modifier modifier = null;
  List<Unit> fieldList = null;
}
{
  modifier = Modifier(){fieldDetails.setModifier(modifier);}
  fieldList = FieldDeclarations(fieldDetails)
  {
    for(Unit fieldUnit: fieldList){
      VariableUnit vUnit = (VariableUnit) fieldUnit;
      vUnit.setLocalVariable(true);    }
    return fieldList;
  }
}

Modifier Modifier():
{
  Modifier modifier = new Modifier();
}
{
  (LOOKAHEAD(2)(<PUBLIC>{modifier.setScopePublic(true);}|<PRIVATE>{modifier.setScopePrivate(true);}|<PROTECTED>{modifier.setScopeProtected(true);})(<STATIC>{modifier.setScopeStatic(true);})
  |LOOKAHEAD(2)(<STATIC>{modifier.setScopeStatic(true);})(<PUBLIC>{modifier.setScopePublic(true);}|<PRIVATE>{modifier.setScopePrivate(true);}|<PROTECTED>{modifier.setScopeProtected(true);})
  |LOOKAHEAD(2)(<PUBLIC>{modifier.setScopePublic(true);}|<PRIVATE>{modifier.setScopePrivate(true);}|<PROTECTED>{modifier.setScopeProtected(true);})
  |LOOKAHEAD(2)(<STATIC>{modifier.setScopeStatic(true);}))?
  {return modifier;}
}

List<Unit> FieldDeclarations(FieldDetails fieldDetails):
{
  SimpleNode type = null;
  List<Unit> variables = null;
}
{
  type = Type(){
    jjtree.popNode();
    fieldDetails.setType(type);
  }
  (< LSB > < RSB >)*
  variables = Variables(fieldDetails)<SCOLON>{return variables;}
}

SimpleNode Type():{
  Token t = null;
  ClassUnit varUnit = null;
}
{
  (t = <INT> {return jjtThis;} #int_AST 
  |t = <CHAR> {return jjtThis;} #char_AST
  |t = <BOOLEAN> {return jjtThis;} #boolean_AST
  |t = <ID> {
    IntegerMuted currentScope = new IntegerMuted();
    if (MODE == 1){		varUnit = (ClassUnit) SYMBOL_TABLE.lookUp(t.image,UnitType.CLASS, currentScope);
		if (varUnit == null){
		  throw new ParseException(t.image + " has not been declared yet");		}
		varUnit.setType(jjtThis);
    }
    return jjtThis;
  } #id_AST)
  }

List<Unit> Variables(FieldDetails fieldDetails):{
  List<Unit> variables = new ArrayList<Unit>();
  Unit variable = null;
}
{
  variable=Variable(fieldDetails){variables.add(variable);}
  (<COMMA> variable=Variable(fieldDetails){variables.add(variable);})*{return variables;}
}

Unit Variable(FieldDetails fieldDetails):{
  VariableUnit variable;
  String variableName = null;
}
{
  variableName = ID(){
    if (MODE == 1) {	    variable = (VariableUnit)SYMBOL_TABLE.add(variableName, UnitType.VARIABLE);
    } else {
        variable = new VariableUnit();    }
  }
  (<LSB><RSB>{variable.setArray(true);})*
  (<ASSIGN> #assignOperator_AST Expression()
    // TODO -- Store value of variable
  )?
  {
    if (MODE == 1) {
	    variable.setType(fieldDetails.getType());
	    variable.setModifier(fieldDetails.getModifier());
    }
    return variable; 
  }
}

Unit Method():{
  MethodUnit methodUnit = new MethodUnit();
  Modifier modifier = null;
  SimpleNode type = null;
  List<Unit> formalArgs = null;
  String methodName = null;
  SimpleNode block = null;
  String functionName = null;
}
{
  modifier = Modifier()
  
  {methodUnit.setModifier(modifier);} 
  ( type = Type() | < VOID > {type = jjtThis; }  #voidType_AST)//{methodUnit.setReturnType(type);}
  (< LSB > < RSB >)*
  functionName = ID()
  <LP>
  {
    methodUnit.setName(functionName);
    SYMBOL_TABLE.enterScopeForUnit(methodUnit, MODE);  }
  ((formalArgs = FormalArgs()){methodUnit.setFormalArgs(formalArgs);})?
  <RP>
  {
    SYMBOL_TABLE.exitScope(MODE);
  }
  Block()//Handle Scoping here
  {return methodUnit;}
}

Unit Ctor():{
  MethodUnit methodUnit = new MethodUnit();
  Modifier modifier = null;
  List<Unit> formalArgs = null;
  Token t = null;
  String functionName = null;
}
{
  modifier = Modifier(){methodUnit.setModifier(modifier);}
  functionName = ID()
  <LP>
  {
    methodUnit.setName(functionName);
    methodUnit.setConstructor(true);
    SYMBOL_TABLE.enterScopeForUnit(methodUnit,MODE);
  }
  (formalArgs = FormalArgs(){methodUnit.setFormalArgs(formalArgs);})?
  <RP>
  {
    SYMBOL_TABLE.exitScope(MODE);
  }
  Block()//Handle Scoping here
  {return methodUnit;}
}

List<Unit> FormalArgs():
{
  Unit formalArg = null;
  List<Unit> formalArgs = new ArrayList<Unit>();
}
{
  formalArg = FormalArg(){formalArgs.add(formalArg);}
  (<COMMA> formalArg = FormalArg(){formalArgs.add(formalArg);})*
  {return formalArgs;}
}

Unit FormalArg():{
  FieldDetails fieldDetails = new FieldDetails();
  Unit formalArg = null;
  SimpleNode type = null;
}
{
  type = Type(){fieldDetails.setType(type);}
  (< LSB > < RSB >)*
  formalArg = Variable(fieldDetails){return formalArg;}
}

void Block() #block_AST:{
}
{
  <LCB>
  {
    SYMBOL_TABLE.enterScope(false, MODE);
  }
  (Statement())*
  <RCB>
  {
    SYMBOL_TABLE.exitScope(MODE);
  }
}

void Statement():{
}
{
  LOOKAHEAD(3)<IF> <LP> Expression() <RP> Statement() (LOOKAHEAD(1) <ELSE> Statement())? #ifThenElseStat_AST
  |<WHILE> <LP> Expression() <RP> Statement() #whileStat_AST
  |<RETURN> (Expression())? <SCOLON> #returnStat_AST
  |LOOKAHEAD(3) StatementExpression() <SCOLON> #expressionStat_AST // Add to Statements attributes
  |LOOKAHEAD(3) FieldDeclarations(new FieldDetails()) #varDeclStat_AST // Add to Statements attributes
  | LOOKAHEAD(3)Block() #block_AST
  |<BREAK> <SCOLON> #breakStat_AST
  |<CONTINUE> <SCOLON> #continueStat_AST
  |<SCOLON> #emptyStat_AST
}

void Literal():{}
{
  <NULL> #nullExpr_AST
  |<TRUE> #boolExpr_AST
  |<FALSE> #boolExpr_AST
  |<INTEGER> #intExpr_AST
  |<CHARLITERAL> #charExpr_AST
  |<STRINGLITERAL> #stringExpr_AST
}

void StatementExpression():{}
{
  LOOKAHEAD(10)
  MethodCall()
  |LOOKAHEAD(10)
  Assignment()
  |LOOKAHEAD(10)
  Expression() 
}

void Assignment():{}
{
  FieldAccess() <ASSIGN> #assignOperator_AST Expression()
}

void FieldAccess():{}
{
  FieldAccess_1()(MethodPrime())? 
}

void FieldAccess_1():{}
{
  LOOKAHEAD(6)
  (PrimaryFieldAccess() <DOT> <ID> #fieldExpr_AST) ((<LSB> Expression() <RSB>)+ #arrayExpr_AST)
  | LOOKAHEAD(6)
  PrimaryFieldAccess() <DOT> <ID> #fieldExpr_AST
  | LOOKAHEAD(6)
  (<ID> #idExpr_AST) ((<LSB> Expression() <RSB>)+ #arrayExpr_AST) 
  | <ID> #idExpr_AST
}

void PrimaryFieldAccess():{}
{
  
  LOOKAHEAD(3) Literal()
  | LOOKAHEAD(3) <THIS> #thisExpr_AST
  | LOOKAHEAD(3) <SUPER> #superExpr_AST
  | LOOKAHEAD(3) <LP> Expression() <RP>
  | LOOKAHEAD(3) <NEW> <ID> <LP> (ActualArguments())? <RP> #newClassExpr_AST
 
}

void MethodCall() #methodCall_AST:{}
{
  MethodCall_1() (MethodCall_2())?
}

void MethodCall_1() #methodCall_AST:{}
{
  MethodParent() (MethodPrime())? <LP>(ActualArguments())?<RP>
}

void MethodCall_2():{}
{
  LOOKAHEAD(5)<DOT> <ID> <LP> (ActualArguments())? <RP> #AstMethodExpr MethodCall_2()
  | LOOKAHEAD(5)
    <DOT> <ID> <LSB> Expression() <RSB> <LP> (ActualArguments())? <RP> MethodCall_2()
  | LOOKAHEAD(5)
    <DOT> <ID> MethodPrime() <LP> (ActualArguments())? <RP> MethodCall_2()
  | LOOKAHEAD(5)
    <DOT> <ID> <LSB> Expression() <RSB> MethodPrime() <LP> (ActualArguments())? <RP> MethodCall_2()
  | LOOKAHEAD(5)
    <DOT> <ID> <LP> (ActualArguments())? <RP>
  | LOOKAHEAD(5)
    <DOT> <ID> <LSB> Expression() <RSB> <LP> (ActualArguments())? <RP>
  | LOOKAHEAD(5)
    <DOT> <ID> MethodPrime() <LP> (ActualArguments())? <RP>
  | LOOKAHEAD(5)
    <DOT> <ID> <LSB> Expression() <RSB> MethodPrime() <LP> (ActualArguments())? <RP>
}

void MethodParent():{}
{
  (PrimaryMethodParent() <DOT> <ID> #fieldExpr_AST)  (<LSB> Expression() <RSB> #arrayExpr_AST)? 
  | (<ID> #idExpr_AST) (<LSB> Expression() <RSB> #arrayExpr_AST)? 

}

void PrimaryMethodParent():{}
{
  LOOKAHEAD(3)
    Literal()
  | LOOKAHEAD(3)
    <THIS> #thisExpr_AST
  | LOOKAHEAD(3)
    <SUPER> #superExpr_AST
  | LOOKAHEAD(3)
    <LP> Expression() <RP>
  | LOOKAHEAD(3)
    <NEW> <ID> <LP> (ActualArguments())? <RP> #methodExpr_AST
}

void MethodPrime():{}
{
  LOOKAHEAD (3)
    <DOT> <ID> #fieldExpr_AST MethodPrime()
  | LOOKAHEAD(3)
    <DOT> <ID> #fieldExpr_AST <LSB> Expression() <RSB> #arrayExpr_AST MethodPrime()
  | LOOKAHEAD(3) <DOT> <ID> #fieldExpr_AST <LSB> Expression() <RSB> #arrayExpr_AST
  | <DOT> <ID> #fieldExpr_AST
}

void ActualArguments():{}
{
  Expression() (<COMMA> Expression())*
}

void Expression():{}
{
  (OrExpression() (LOOKAHEAD(1) <ASSIGN> #assignOperator_AST Expression())?)  #binaryExpression_AST(>2)
  /**(LOOKAHEAD(10 )
  OrExpression() <ASSIGN> #assignOperator_AST Expression()
  | LOOKAHEAD(10) OrExpression()) #binaryExpression_AST(>1)**/
}

void OrExpression():{}
{
  (AndExpression() (LOOKAHEAD(1) <OR> #orOperator_AST OrExpression())?)  #binaryExpression_AST(>1)
  /**(LOOKAHEAD(10)
  AndExpression() <OR> #orOperator_AST OrExpression()
  | LOOKAHEAD(10) AndExpression()) #binaryExpression_AST(>1)*/
}

void AndExpression():{}
{
  (EqualityExpression() (LOOKAHEAD(1) <AND> #andOperator_AST AndExpression())?)  #binaryExpression_AST(>1)
  /*(LOOKAHEAD(10)
  EqualityExpression() <AND> #andOperator_AST AndExpression()
  | LOOKAHEAD(10) EqualityExpression()) #binaryExpression_AST(>1)*/
}

void EqualityExpression():{}
{
  (RelationalExpression() (LOOKAHEAD(1)(LOOKAHEAD(1) (<EQUAL> #equalOperator_AST EqualityExpression())
  | LOOKAHEAD(1) (<NOTEQUAL> #notEqualOperator_AST EqualityExpression())))?) #binaryExpression_AST(>1)
  /*(LOOKAHEAD(10)
  RelationalExpression() <EQUAL> #equalOperator_AST EqualityExpression()
  | LOOKAHEAD(10) RelationalExpression()) #binaryExpression_AST(>1)*/
}

void RelationalExpression():{}
{
  (SumExpression() (LOOKAHEAD(1)(LOOKAHEAD(1) (<GREATER> #greaterOperator_AST RelationalExpression())
  | LOOKAHEAD(1) (<GREATEREQ> #greaterEqualOperator_AST RelationalExpression())
  | LOOKAHEAD(1) (<LESSER> #lesserOperator_AST RelationalExpression())
  | LOOKAHEAD(1) (<LESSEREQ> #lesserEqualOperator_AST RelationalExpression())))?) #binaryExpression_AST(>1)
  /*(LOOKAHEAD(10) SumExpression() <GREATER> #greaterOperator_AST RelationalExpression()
  |LOOKAHEAD(10) SumExpression() <GREATEREQ> #greaterEqualOperator_AST RelationalExpression()
  |LOOKAHEAD(10) SumExpression() <LESSER> #lesserOperator_AST RelationalExpression()
  |LOOKAHEAD(10) SumExpression() <LESSEREQ> #lesserEqualOperator_AST RelationalExpression()
  |LOOKAHEAD(10) SumExpression()) #binaryExpression_AST(>1)*/
}

void SumExpression():{}
{
  (FactorExpression() (LOOKAHEAD(1)(LOOKAHEAD(1)(<PLUS> #plusOperator_AST SumExpression())
  | LOOKAHEAD(1)( <MINUS> #lesserEqualOperator_AST SumExpression())))?) #binaryExpression_AST(>1)
  /*
  (LOOKAHEAD(10) FactorExpression() <PLUS> #plusOperator_AST SumExpression()
  |LOOKAHEAD(10) FactorExpression() <MINUS> #minusOperator_AST SumExpression()
  |LOOKAHEAD(10) FactorExpression())#binaryExpression_AST(>1)*/
}

void FactorExpression():{}
{
  (UnaryExpression() (LOOKAHEAD(1)(LOOKAHEAD(1)( <MULTIPLY> #multiplyOperator_AST FactorExpression())
  | LOOKAHEAD(1)( <DIVIDE> #divideOperator_AST FactorExpression())
  | LOOKAHEAD(1)( <MODULO> #moduloOperator_AST FactorExpression())))?) #binaryExpression_AST(>1)
  /*
  (LOOKAHEAD(10) UnaryExpression() <MULTIPLY> #multiplyOperator_AST FactorExpression()
  |LOOKAHEAD(10) UnaryExpression() <DIVIDE> #divideOperator_AST FactorExpression()
  |LOOKAHEAD(10) UnaryExpression())#binaryExpression_AST(>1)*/
}

void UnaryExpression():{}
{
  (<PLUS> #plusOperator_AST| <MINUS> #minusOperator_AST| <NOT> #notOperator_AST) Expression()
  | Primary()
}

void Primary(): {}
{
  LOOKAHEAD(5) PrimaryExisting()
  | LOOKAHEAD(5) NewArray()
}

void PrimaryExisting(): {}
{
  PrimaryExisting_1()  (PrimaryExisting_2())?
}

void PrimaryExisting_1():{}
{
  LOOKAHEAD(3)
    Literal()
  | LOOKAHEAD(3)
    <THIS> #thisExpr_AST
  | LOOKAHEAD(3)
    <SUPER> #superExpr_AST
  | LOOKAHEAD(3)
    <LP> Expression() <RP>
  | LOOKAHEAD(3)
    <NEW> <ID> <LP> (ActualArguments())? <RP> #newClassExpr_AST
  | LOOKAHEAD(3)
    <ID>  <LP> (ActualArguments())? <RP> #methodExpr_AST
  | LOOKAHEAD(3)
    <ID> (<LSB> Expression() <RSB>)+ #arrayExpr_AST
  | <ID> #idExpr_AST
}

void PrimaryExisting_2():{}
{
    (<DOT> <ID> #fieldExpr_AST) ((<LP> (ActualArguments())? <RP> #methodExpr_AST)
    | (<LSB> Expression() <RSB> #arrayExpr_AST))? (PrimaryExisting_2())?
    
    /*LOOKAHEAD(5)  
      < DOT > <ID > <LP> (ActualArguments())? <RP> #methodExpr_AST PrimaryExisting_2()
    | LOOKAHEAD(5)
      < DOT > <ID > #fieldExpr_AST PrimaryExisting_2()
    | LOOKAHEAD(5)
      < DOT > <ID > <LSB> Expression() <RSB> #arrayExpr_AST PrimaryExisting_2()
    | LOOKAHEAD(3)
      < DOT > <ID > <LSB> Expression() <RSB> #arrayExpr_AST
    | LOOKAHEAD(3)
      < DOT > <ID > <LP> (ActualArguments())? <RP> #methodExpr_AST
    | < DOT > <ID > #fieldExpr_AST*/
}

void NewArray():{}
{
  <NEW> Type() (<LSB> Expression() <RSB>)+
}