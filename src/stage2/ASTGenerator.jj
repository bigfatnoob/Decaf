/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options
{
  JDK_VERSION = "1.5";
  static = true;
  NODE_PREFIX = ""; // No prefix for generated AST classes
  MULTI = true;   // many class names
}
PARSER_BEGIN(AST)package stage2;

public class AST
{
  public static void main(String args [])
  {
    System.out.println("Reading from standard input...");
    System.out.print("Enter an expression like \"1+(2+3)*var;\" :");
    new AST(System.in);
    try
    {
      SimpleNode n = AST.Start();
      n.dump("");
      System.out.println("Thank you.");
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }

  public static position xtractPos(Token t) {
    return new position(t.beginLine, t.beginColumn, t.endLine, t.endColumn);
  }
}PARSER_END(AST)SKIP :  /* Whitespace */
{
  " "
| "\r"
| "\t"
| "\n"
| <"//"(~["\n","\r"])*("\n"|"\r"|"\n\r")>   // Single Line Comment
| <"/*">: CMNT_BODY                         // Multi Line Comment
}

<CMNT_BODY>
SKIP:
{
  <"*/">: DEFAULT
| <~[]>
}



TOKEN : 
{
  /* Keywords */
  < BREAK : "break">
| < CLASS : "class">
| < CONTINUE : "continue">
| < ELSE : "else">
| < EXTENDS : "extends">
| < IF : "if">
| < NEW : "new">
| < PRIVATE : "private">
| < PROTECTED : "protected">
| < PUBLIC : "public">
| < RETURN : "return">
| < STATIC : "static">
| < SUPER : "super">
| < THIS : "this">
| < WHILE : "while">
| < BOOLEAN : "boolean">
| < CHAR : "char" >
| < VOID : "void" >
  /* Forbidden Keywords from JAVA */
| < ABSTRACT : "abstract">
| < BYTE : "byte">
| < CASE : "case">
| < CATCH : "catch">
| < CONST : "const">
| < DEFLT : "default">
| < DO : "do">
| < DOUBLE : "double">
| < FINAL : "final">
| < FINALLY : "finally">
| < FOR : "for">
| < IMPLEMENTS : "implements">
| < IMPORT : "import">
| < INSTANCEOF : "instanceof">
| < INTERFACE : "interface">
| < LONG : "long">
| < NATIVE : "native">
| < GOTO : "goto">
| < PACKAGE : "package">
| < SHORT : "short">
| < SWITCH : "switch">
| < SYNCHRONIZED : "synchronized">
| < THROW : "throw">
| < THROWS : "throws">
| < TRANSIENT : "transient">
| < TRY : "try">
| < VOLATILE : "volatile">
  /* Reserved for possible future extension */
| < BYVALUE : "byvalue">
| < CAST : "cast">
| < FUTURE : "future">
| < GENERIC : "generic">
| < INNER : "inner">
| < NONE : "none">
| < OPERATOR : "operator">
| < OUTER : "outer">
| < REST : "rest">
| < VAR : "var">
  /* Literals */
| < INTEGER: "0"|(["1"-"9"](["0"-"9"])*)>
| < TRUE: "true" >
| < FALSE: "false" >
// TODO verify character definition
| < CHARLITERAL: "'"(~["'", "\\"])|("\\"["a"-"z", "A"-"Z", "0"-"9"])|(" ")"'">
| < STRINGLITERAL: "\""((~["\"","\n","\r"])|("\\\""))*"\"">
| < NULL: "null">
  /* Punctuation */
| < LP: "(" >
| < RP: ")" >
| < LCB: "{" >
| < RCB: "}" >
| < LSB: "[" >
| < RSB: "]" >
| < SCOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
  /* Operators */
| < ASSIGN: "=" >
| < GREATER: " >" >
| < LESSER: "<" >
| < NOT: "!" >
| < EQUAL: "==" >
| < GREATEREQ: ">=" >
| < LESSEREQ: "<=" >
| < NOTEQUAL: "!=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < AND: "&&">
| < OR: "||">
| < MODULO: "%">
  /* Identifiers */
| < #Let : ["a"-"z", "A"-"Z"]>
| < #Dig : ["0"-"9"]>
| < ID: ("$"|"_"|<Let>)("$"|"_"|<Let>|<Dig>)*>
| < EMPTY : ""> : MATCH_NON_EMPTY
}

< MATCH_NON_EMPTY>
TOKEN:
{
  <NON_EMPTY : ~[]>
}

Prgrm Start():
 {classDef C;
  LinkedList<classDef> L = new LinkedList<classDef>();}
 { (C = ClassBlock()    {L.addLast(C);})*
    {return new Prgrm(L);}  }

classDef ClassBlock():{}{
  < VOID>}



